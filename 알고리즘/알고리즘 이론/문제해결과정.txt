#
알고리즘 문제를 해결하는 과정
## 1. 문제를 이해한다. 
1. 문제를 내 방식대로 다시 생각할 수 있는가.
2. 문제가 어떤 입력값을 담고 있는지 이해한다.
3. 문제에 대한 해결책에서 나와야 할 결과는 무엇인가.
4. 입력값이 출력값을 결정할 수 있는가.
   문제를 해결할 충분한 정보가 주어졌는가.
   입력값을 알고 있다면 해당 정보만 사용해서 출력값을 예상할 수 있는가. (때로는 파악할 수 있을 때까지 기다려야 하는 경우도 있다.)
5. 문제의 일부인 데이터의 중요한 부분에 어떻게 라벨을 지정할 수 있을지. (문제에서 정말 중요한 것이 무엇인가.)
ex) 두 숫자를 입력 받고 둘의 합을 반환하는 함수를 작성해라
1.
더하기 구현
2. 
숫자 2개를 입력받는다. (int, float, string 등으로 input)
조금 복잡하게 생각해본다면 숫자가 정수인지 부동 소수점인지 숫자가 얼마나 큰 지.
또한 누군가가 한 입력값을 없애버릴 수도 있다. 혹은 누군가 4개나 10개의 숫자를 더하려는 경우
3.
정수로 반환할 지, 부동소수로 반환할지, 큰 숫자로 인해 정수를 반환할지
4.
숫자 2개를 더하는 함수인데 1개만 입력 받았을 경우.
0을 더해야 할 지, null이나 undefined를 반환해야 할 지.
5.
입력값과 출력값이 제일 중요하다.
num1과 num2라는 입력값, sum이라는 출력값

## 2. 구체적인 예시를 만든다.
1. 간단한 예시로 시작한다.
- 입력값과 출력값의 순서대로 예시를 두 세개 작생하본다.
2. 가장 쉬운 사용 사례와 같은 예시들로부터 더 복작한 예시들로 진행한다.
3. 빈 입력값이 있는 예제를 살펴보는 것 
4. 특히 유효하지 않은 입력값이 주어진 상황에서 문제를 어떻게 해결해야 할 지
ex) 입력받은 문자열에 대해 각 문자 별로 개수를 구하는 함수를 작성해라
1. 
charCount('aaaa') // {a:4}
charCount('hello') // {h:1, e:1, l:2, o:1}
2.
charCount('my phone number is 182384')
charCount('Hello hi')
3.
charCount('')
4.
charCount([], {})

## 3. 문제를 세분화 한다.
문제를 해결할 단계들을 명확히 작성해본다.
모든 라인마다 작성할 필요는 없고, 해결책의 기본적인 구성요소만 작성하면 된다.
그럼으로써 코드를 실제로 작성하기 전에 한 번 더 생각해볼 수 있게 해준다.
자유분방하게 코드를 떠오르는대로 입력하는 게 아니라 감이 잡히지 않거나 이해되지 않는 부분들을 파악하게 하거나 이해할 수 있게 해준다.
쉽게 말해 문제를 세분화 하는 것은 단계의 틀을 잡고 항상 집중할 수 있도록 도울 뿐만 아니라 확신이 들지 않는 문제를 짚을 수 있게 해준다. 
ex)
function charCount(str) {
  // 마지막에 반환할 object를 만든다.
  // str을 loop를 통해 각 문자에 접근
    // 각 문자가 숫자나 문자(알파벳)이고 객체에 key값으로써 존재하고 있다면 1을 더한다.
    // 각 문자가 숫자나 문자(알파벳)이고 객체에 key값으로써 존재하고 있지 않다면, 객체에 추가한 후 값을 1로 지정
    // 각 문자가 숫자나 문자(알파벳)이 아니라면 (띄어스기, 특수문자, 기타.) 아무것도 하지 않는다.
  // 객체를 반환한다.
}

## 4. 해결/단순화
해결할 수 있다면 해결하고 해결할 수 없다면 더 단순한 문제를 해결하라. (해결해야 할 대상을 아예 바꾸라는 소리가 아님)
다른 모든 것에 집중하기 위해 시간이 많이 소요되는 부분을 무시한다.
보통 문제를 단순화하는 과정에서 실제 해결책을 깊이 이해하고 문제의 어려운 부분을 파악하면서 점차 해결된다.
쉽게 말해 잠깐 동안 어려운 부분을 무시하고 단순한 해결책을 작성한 다음 다시 어려운 부분을 가능하면 다시 통합시키는 것이다.
1. 문제를 해결하며 어려운 부분들을 찾는다.
2. 일시적으로 어려움을 무시한다.
3. 단순한 해결책을 작성한다.
4. 어려운 부분을 하나하나 해결하며 통합한다.
ex)
function charCount(str){
  // 마지막에 반환할 object를 만든다.
  let result = {};
  // str을 loop를 통해 각 문자에 접근
  for(let i=0; i<str.length; i++){
    let char = str[i].toLowerCase();
    // 각 문자가 숫자나 문자(알파벳)이고 객체에 key값으로써 존재하고 있다면 1을 더한다.
    if (result[char]>0){
      result[char]++;
    // 각 문자가 숫자나 문자(알파벳)이고 객체에 key값으로써 존재하고 있지 않다면, 객체에 추가한 후 값을 1로 지정
    }else{
      result[char] = 1
    }
  }
  // 객체를 반환한다.
  return result
}
1. 각 문자가 숫자나 문자인지 판별하는 부분, 대소문자 구분이 해결되지 않았다..
2. 일단 무시한다.
3. 객체에 그냥 다 추가한다.
4. 대소문자 부분을 해결한다.
4과정의 반복

## 5. 되돌아보기&리팩토링
코드를 향상시키고자 노력하는 것은 정말 중요하다.
시간을 내어 코드를 살펴보고, 되돌아보고, 성찰한다.
각 구성요소를 한 줄씩 살펴보면서 마음에 들지 않는 부분이나, 코드의 형태, 해석 방법, 또 이해하기 얼마나 쉬운지에 대해 생각한다.
대부분의 사람들이 중요하게 여기는 것은 코드가 얼마나 효율적인지이다.
그러나 대체로 효율성과 가독성이라는 두 기둥 사이에 균형을 맞춰야 할 필요가 있다.
문제를 해결함으로써 얻을 수 있는 큰 이점 중 하나는 직감을 발달시켜 다른 문제를 해결할 수 있는 직관력을 길러준다는 것이다.
### 리팩토링 질문
- 결과를 확인할 수 있는가
코드가 제대로 작동하는 지 확인해야 한다.
- 결과를 다른 방식으로 도출할 수 있는가
문제에 대한 해결책의 다른 접근 방법이 있는가, 한 눈에 보고 이해할 수 있는지, 해결책이 얼마나 직관적인지
- 결과나 함수를 다른 문제에도 적용할 수 있나
- 해결책의 성능을 향상시킬 수 있는가
주로 시간복잡도와 공간복잡도를 고려한다.
- 코드를 향상시킬 방안에 대해 생각했는가
면접시 시간은 없지만 코드를 깔끔하게 만들 의향이 있다는 것을 알리는 것이 중요하다.
- 다른 사람들이 이 문제를 푸는 것을 본 적이 있는지
다른 사람이 같은 문제를 어떻게 해결했는지를 보면 많은 것을 배울 수 있다.
자바스크립트로 해결된 문제를 확인할 수 없을때 파이썬이나 자바로 해결된 문제를 찾아 리팩토링해도 괜찮다.
ex)
function charCount(str){
  let obj = {};
  for (let i=0; i<str.length; i++){
    let char = str[i].toLowerCase();
    if (/[a-z0-9]/.test(char)){
      if (obj[char]>0){
        obh[char]++
      }else{
        obj[char] =1;
      };
    }
  }
  return obj;
}
아래는 미적인 부분을 고려한 것이다.
function charCount(str){
  let obj = {};
  for (let char of str){
    char = char.toLowerCase();
    if (/[a-z0-9]/.test(char)){
      obj[char] = ++obj[char] || 1;
    }
  }
  return obj;
}
정규표현식을 사용하지 않고 리팩토링 해본다.
function charCount(str){
  let obj = {};
  for (let char of str){
    if (isAlphaNumber(char)){
      char = char.toLowerCase();
      obj[char] = ++obj[char] || 1;
    }
  }
  return obj;
}
function isAlphaNumber(char){
  let char = char.charCodeAt(0);
  if (!(code > 47 && code < 58) && // 숫자 (0-9)
      !(code > 64 && code < 91) && // 대문자 (A-Z)
      !(code > 96 && code < 123)){ // 소문자 (a-z)
        return false;
      }
  return true
}
추가)
정규표현식을 사용하는 건 상당히 좋다. 
신용카드 패턴, 전화번호, 주소나 URL 패턴 같은 복잡한 패턴을 찾는 데 아주 좋기 때문이다.
허나 정규표현식을 사용한 코드와 그렇지 않은 코드가 사용중인 브라우저에 따라 성능에 차이가 있는 경우도 있다.
