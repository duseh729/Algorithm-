#
c언어의 배열은 크기가 고정되어 있고,
같은 타입의 데이터만 담을 수 있다.
c언어의 배열은 주솟값에 연속적으로 값을 입력하는 방식이다.
이와 다르게 파이썬의 배열은 각 인덱스마다 값의 레퍼런스를 가리키기 때문에
큰 값을 넣거나 작은 값을 넣거나 상관이 없다.

#
정적배열: 크기 고정(요소 수 제한)
동적배열: 크기 변함(요소 계속 추가 가능)
#동적배열:
정적배열로 만들어진 자료구조
정적 배열의 크기를 상황에 맞게 조절한다.
배열이 꽉 찬다면 2배 정도 큰 배열을 만든다.
그리고 값을 복사하고 값을 추가한다.

#
동적 배열 추가 연산 시간 복잡도:
1. 배열에 여유 공간이 있을 때 : O(1) <- 자주 일어남
2. 정적 배열이 꽉 찼을 때ㅣ O(n) <- 가끔 일어남
보통 시간 복잡도를 얘기할 때 최악의 경우를 말한다.
허나 가끔 일어나는 최악의 경우는 불합리하다 볼 수 있다.
# 분할 상환 분석(Amortized Analysis): 할부
같은 동작을 n번 했을 때 드는 시간이 x일 때
동작을 한 번 하는 데 걸린 시간은 x/n
~
분할 상환 분석은 최악의 시간을 얘기하지 않고 평균을 얘기한다.
최악의 경우로 시간 복잡도를 얘기하는 것이 비합리적인 경우에 사용한다.
~
분할 상환 분석을 한다고 꼭 시간 복잡도가 줄어드는 건 아니다.
보통은 할부 개념을 적용해도 시간 복잡도가 줄어들진 않는다.
하지만 최악의 경우보다 분할 상환 분석을 한 시간 복잡도가 더 적다면
분할상환분석 시간복잡도를 사용한다.
쉽게 말해 '동적 배열의 끝에 데이터를 추가할 때는 O(1)이 걸린다'라 해도 된다는 소리다.

#
동적 배열 삽입 연산:
1. 정적 배열에 남는 공간이 있을 때:
최악의 경우 0번 인덱스에 넣을 떄: O(n)
2. 정적 배열이 찼을 때:
최악의 경우 : O(n)
둘 다 가장 뒤에 넣을 때 삽입 연산은 O(1)

#
동적 배열 삭제 연산:
가장 앞 인덱스를 지울 떄 : O(n)
가장 뒤 인덱스르 지울 떄 : O(1)
분할 상환 분석 적용이 가능하다.

#
배열과 동적배열 비교
#연산&시간 복잡도
배열 동적배열
접근: O(1)
탐색: O(n)
배열은 삽입과 삭제가 자연스럽게 가능하지 못한다.
동적배열은 자연스업게 가능하고, 최고의 경우 O(1)이고 최악의 경우는 O(n)이다.
#낭비하는 공간
배열: 크기가 고정되어 있기 때문에 낭비하는 공간이 없다.
동적 배열: 고간을 낭비할 수도 있고 안 할 수도 있다.

#
배열에 데이터 삽입을 못하는 이유:
크기가 고정되어 있는 배열에는 처음 정한 수보다 더 많은 데이터를 삽입할 수 없다.
#
배열에 데이터 삭제를 못하는 이유:
ex) 
정수 4개를 담을 수 있는 배열에 2,3,5,7이 저장돼 있다고 한다.
여기서 인덱스 1에 있는 3을 지우고 뒤에 인덱스를 앞으로 옮기면
2,5,7,7이 된다. 문제는 인덱스 3에 저장되어 있던 7을 메모리에서 자연스럽게
지울 수 있는 방법이 마땅히 없다. 그래서 자연스럽게 삭제를 할 수 없다.
#
동적 배열의 삭제:
정적배열과 동일하지만 파이썬이 내부적으로 개발자가 접근할 수 있는 인덱스 범위를
0~2로 만들어 버려서 더이서 인덱스 3에 접근할 수 없다.
그래서 실질적으로 삭제되었다고 볼 수 있다.